pipeline {
    agent any

    environment {
        IMAGE_TAG = "v${env.BUILD_NUMBER}"
        PROJECT_NAME = "radwasamir"
        APP_PORT = "2222"  # Host port
        CONTAINER_PORT = "5000"  # Flask's internal port
        SLACK_CHANNEL = "#project"
    }

    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Checkout Code') {
            steps {
                checkout scm
                script {
                    echo "Repository structure verified:"
                    sh "ls -la insert-update/"
                }
            }
        }

        stage('Verify Files') {
            steps {
                script {
                    def requiredFiles = [
                        'insert-update/Dockerfile',
                        'insert-update/docker-compose.yml',
                        'insert-update/app.py'
                    ]
                    
                    requiredFiles.each { file ->
                        if (!fileExists(file)) {
                            error("‚ùå Missing required file: ${file}")
                        }
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    dir("insert-update") {
                        docker.build("${PROJECT_NAME}:${IMAGE_TAG}")
                    }
                }
            }
        }

        stage('Deploy Application') {
            steps {
                script {
                    dir("insert-update") {
                        // Clean previous deployment
                        sh "docker-compose down --remove-orphans || true"
                        
                        // Start services with rebuild
                        sh """
                        IMAGE_TAG=${IMAGE_TAG} \
                        APP_PORT=${APP_PORT} \
                        CONTAINER_PORT=${CONTAINER_PORT} \
                        docker-compose up -d --build
                        """
                        
                        // Wait for database
                        sh """
                        echo "Waiting for database to be ready..."
                        docker-compose exec -T db bash -c 'while ! pg_isready -U postgres; do sleep 5; done'
                        """
                        
                        // Health check with retries
                        def healthy = false
                        def maxRetries = 5
                        def waitSeconds = 10
                        
                        for (int i = 1; i <= maxRetries; i++) {
                            sleep(time: waitSeconds, unit: 'SECONDS')
                            
                            def status = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:${APP_PORT} || echo '000'",
                                returnStdout: true
                            ).trim()
                            
                            if (status == "200") {
                                healthy = true
                                echo "‚úÖ Health check passed (Status: 200)"
                                break
                            } else {
                                echo "‚ö†Ô∏è Attempt ${i}/${maxRetries} - Status: ${status}"
                                sh "docker-compose logs --tail=20 || true"
                            }
                        }
                        
                        if (!healthy) {
                            error("‚ùå Application failed to start after ${maxRetries} retries")
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // Archive logs on failure
                if (currentBuild.result == 'FAILURE') {
                    dir("insert-update") {
                        sh "docker-compose logs --no-color > deployment_logs.txt 2>&1 || true"
                        archiveArtifacts artifacts: 'deployment_logs.txt', allowEmptyArchive: true
                    }
                }
                cleanWs()
            }
        }
        
        success {
            script {
                def commitHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                slackSend(
                    channel: env.SLACK_CHANNEL,
                    color: "good",
                    message: """üöÄ Deployment Successful!
                    |*Service*: ${PROJECT_NAME}:${IMAGE_TAG}
                    |*Commit*: ${commitHash}
                    |*URL*: http://your-server:${APP_PORT}
                    |<${env.BUILD_URL}|View Build>""".stripMargin()
                )
            }
        }
        
        failure {
            script {
                slackSend(
                    channel: env.SLACK_CHANNEL,
                    color: "danger",
                    message: """üî• Deployment Failed!
                    |*Build*: #${env.BUILD_NUMBER}
                    |*Logs*: <${env.BUILD_URL}/artifact/deployment_logs.txt|Download>
                    |<${env.BUILD_URL}|Investigate>""".stripMargin()
                )
            }
        }
    }
}
